// src/parser/grammar.pest

// ======================
// 基础词法规则
// ======================
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!("\n" | "\r") ~ ANY)* }  // 单行注释

// 标识符（首字母非数字）
identifier = @{ 
    !(keyword | reserved_literal | time_unit) ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")*
}

// 字面量
integer = @{ ("-")? ~ ASCII_DIGIT+ }
positive_integer = @{ ASCII_DIGIT+ }
float = @{ 
    ("-")? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ |
    ("-")? ~ ASCII_DIGIT+ ~ ("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+
}
string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
boolean_true = @{ "true" }
boolean_false = @{ "false" }
boolean = { boolean_true | boolean_false }
null = @{ "null" }

//时间字面量，后续扩展为单位系统
time_unit_s = @{ "s" }
time_unit_ms = @{ "ms" }
time_unit_us = @{ "us" }
time_unit_ns = @{ "ns" }
time_unit = { time_unit_s | time_unit_ms | time_unit_us | time_unit_ns }
time_literal = @{ positive_integer ~ "_" ~ time_unit }  // 10_s

// 类型相关字面量
type_path = @{
    identifier ~ ("::" ~ identifier)* 
}
generic_type = @{
    identifier ~ "<" ~ generic_args ~ ">"
}
generic_args = {
    type_spec ~ ("," ~ type_spec)*
}

// ======================
// 关键字和保留字
// ======================
keyword_import = @{ "import" }
keyword_enum = @{ "enum" }
keyword_struct = @{ "struct" }
keyword_impl = @{ "impl" }
keyword_event = @{ "event" }
keyword_component = @{ "component" }
keyword_entity = @{ "entity" }
keyword_describe = @{ "describe" }
keyword_entity_proto = @{ "enproto" }
keyword_system = @{ "system" }
keyword_query = @{ "query" }
keyword_where = @{ "where" }
keyword_update = @{ "update" }
keyword_every = @{ "every" }
keyword_watch = @{ "watch" }
keyword_priority = @{ "priority" }
keyword_summon = @{ "summon" }
keyword_world = @{ "world" }
keyword_with = @{ "with" }
keyword_as = @{ "as" }
keyword_match = @{ "match" }
keyword_if = @{ "if" }
keyword_else = @{ "else" }
keyword_while = @{ "while" }
keyword_let = @{ "let" }
keyword_fn = @{ "fn" }
keyword_return = @{ "return" }
keyword_or = @{ "or" }
keyword_and = @{ "and" }
keyword_dict = @{ "Dict" }

keyword_int = @{ "int" }
keyword_float = @{ "float" }
keyword_str = @{ "str" }
keyword_bool = @{ "bool" }

keyword = {
    keyword_import | keyword_enum | keyword_struct | keyword_impl | keyword_event |
    keyword_component | keyword_describe | keyword_entity_proto | keyword_system |
    keyword_query | keyword_where | keyword_update | keyword_every | keyword_watch |
    keyword_priority | keyword_summon | keyword_world | keyword_with | keyword_as |
    keyword_match | keyword_if | keyword_else | keyword_while | keyword_let | keyword_fn |
    keyword_return  | keyword_or | keyword_and |
    keyword_dict | keyword_entity
}
reserved_literal = {boolean_true | boolean_false | null}

// ======================
// 复合类型定义
// ======================
enum_def = {
    keyword_enum ~ identifier ~ "{" ~
    (identifier ~ ("," | &"}"))* ~ 
    "}"
}

struct_def = {
    keyword_struct ~ identifier ~ "{" ~
    (field_def ~ ("," | &"}")?)* ~ 
    "}"
}

field_def = {
    identifier ~ ":" ~ type_spec
}

type_spec = {
    primitive_type | 
    list_type | 
    tuple_type | 
    dict_type | 
    type_path |
    generic_type
}


primitive_type = { keyword_int | keyword_float | keyword_str | keyword_bool | keyword_entity }
list_type = { "[" ~ type_spec ~ "]" }
tuple_type = { "(" ~ type_spec ~ ("," ~ type_spec)* ~ ")" }
dict_type = { keyword_dict ~ "<" ~ type_spec ~ "," ~ type_spec ~ ">" }

// ======================
// ECS 核心结构
// ======================
component_def = {
    keyword_component ~ identifier ~ "{" ~
    (field_def ~ ("," | &"}")?)* ~ 
    "}"
}

event_def = {
    keyword_event ~ identifier ~ "{" ~
    (field_def ~ ("," | &"}")?)* ~ 
    "}"
}

entity_proto_def = {
    keyword_entity_proto ~ identifier ~ "{" ~
    ("with" ~ component_init ~ ("," | &"}")?)* ~ 
    "}"
}

component_init = {
    identifier ~ "(" ~ 
    (field_init ~ ("," | &")")?)* ~ 
    ")"
}

field_init = {
    identifier ~ ":" ~ expression
}

// ======================
// 系统定义
// ======================
system_def = {
    keyword_system ~ identifier ~
    query_block ~ 
    update_block? ~ 
    watch_block*
}

query_block = {
    keyword_query ~
    comp_constraint ~ "as" ~ identifier ~
    ("where" ~ condition)?
}
comp_constraint = {
    comp_constraint_primitive |
    comp_constraint_list |
    comp_constraint_tuple
}

comp_constraint_primitive = {
    component_ref ~ ("+" ~ component_ref)*
}
comp_constraint_list = {
    "[" ~ comp_constraint_primitive ~ "]"
}
comp_constraint_tuple = {
    "(" ~ comp_constraint_primitive ~ ")"
}

component_ref = { 
    identifier ~ ("::" ~ identifier)? 
}

condition = { expression }  // 暂时简化处理，实际需要限定为逻辑表达式

update_block = {
    keyword_update ~ keyword_every ~ time_literal ~ closure
}


watch_block = {
    keyword_watch ~ "{" ~
    (event_trigger ~ ("," ~ event_trigger)*)? ~
    ("," ~ catch_all_match)? ~
    "}"
}
event_trigger = {
    priority_attr? ~ event_match
}
priority_attr = { "@" ~ keyword_priority ~ "(" ~ integer ~ ")" }

event_match = {
    identifier ~ "=>" ~ closure
}

catch_all_match = { "_" ~ "=>" ~ closure }

// ======================
// 世界定义
// ======================
world_def = {
    keyword_world ~ identifier ~ "{" ~
    (keyword_with ~ system_init ~ ("," | &"}")?)* ~
    "}"
}

system_init = {
    identifier ~ "(" ~
    (expression ~ ("," | &")")?)* ~
    ")"
}
//自定义结构规则（总括）
custom_def = {
    enum_def |
    struct_def |
    event_def |
    component_def |
    entity_proto_def |
    system_def |
    world_def
}

// ======================
// 表达式层级重构（保留左结合性）
// ======================
expression = { logic_or }

// logic_or (左结合)
op_or = { keyword_or }
logic_or = {
    logic_and ~ logic_or_tail*
}
logic_or_tail = {
    op_or ~ logic_and
}

// logic_and (左结合)
op_and = { keyword_and }
logic_and = {
    equality ~ logic_and_tail*
}
logic_and_tail = {
    op_and ~ equality
}

// equality (禁止链式)
op_eq = { "==" }
op_neq = { "!=" }
equality = {
    comparison ~ ( (op_eq | op_neq) ~ comparison )?
}

// comparison (禁止链式)
op_lt = { "<" }
op_gt = { ">" }
op_leq = { "<=" }
op_geq = { ">=" }
comparison = {
    addition ~ ( (op_lt | op_gt | op_leq | op_geq) ~ addition )?
}

// addition (左结合)
op_add = { "+" }
op_subtract = { "-" }
addition = {
    multiplication ~ addition_tail*
}
addition_tail = {
    (op_add | op_subtract) ~ multiplication
}

// multiplication (左结合)
op_multiply = { "*" }
op_divide = { "/" }
op_modulo = { "%" }
multiplication = {
    unary ~ multiplication_tail*
}
multiplication_tail = {
    (op_multiply | op_divide | op_modulo) ~ unary
}

// unary (右结合保持不变)
op_negate = { "-" }
op_not = { "!" }
unary = {
    (op_negate | op_not)* ~ primary
}

// primary
primary = {
    grouped_expr |
    tuple_expr |
    literal |
    identifier |
    function_call |
    match_expr |
    if_expr |
    while_expr |
    closure |
    block
}

// 以下规则保持不变...
grouped_expr = { "(" ~ expression ~ ")" }
tuple_expr = {
    "(" ~ ")" |
    "(" ~ expression ~ "," ~ expression ~ ("," ~ expression)* ~ ")"
}
literal = { integer | float | string | time_literal | boolean | null }
function_call = {
    identifier ~ "(" ~  argument_list? ~ ")"
}
argument_list = {
    expression ~ ("," ~ expression)*
}
match_expr = {
    "match" ~ expression ~ "{" ~
    match_arms? ~
    "}"
}
match_arms = {
    match_arm ~ ("," ~ match_arm)* ~ ","?
}
match_arm = {
    pattern ~ "=>" ~ block
}
// pattern matching, 暂且先将就一下
pattern = {
    tuple_pattern |
    identifier |
    literal |
    "_"
    // | struct_pattern
}

tuple_pattern = {
    "(" ~ pattern ~ ("," ~ pattern)* ~ ")"
}

// struct_pattern = {
//     identifier ~ "{" ~ (identifier ~ (":" ~ pattern)? ~ ("," | &"}")?)* ~ "}"
// }
if_expr = {
    keyword_if ~ expression ~ block ~
    (keyword_else ~ (if_expr | block))?
}
while_expr = {
    keyword_while ~ expression ~ block
}
block = {
    "{" ~
        (statement)* ~
        expression? ~
    "}"
}
statement = {
    let_stmt |
    expression_stmt |
    return_stmt |
    summon_stmt |
    import_stmt
}
let_stmt = { keyword_let ~ identifier ~ ":" ~ type_spec ~ ("=" ~ expression)? ~ ";" }
expression_stmt = { expression ~ ";" }
return_stmt = { keyword_return ~ expression? ~ ";" }
summon_stmt = { keyword_summon ~ identifier ~ component_init? ~ (keyword_with ~ component_init)* ~ ";" }
import_stmt = {
    keyword_import ~
    identifier ~ ("::" ~ identifier)* ~
    (keyword_as ~ identifier)? ~ ";"
}
closure = {
    "|" ~ closure_param_list? ~ "|" ~ block
}
closure_param_list = {
    closure_param ~ ("," ~ closure_param)*
}
closure_param = {
    identifier ~ (":" ~ type_spec)?
}

// ======================
// 顶层结构
// ======================


top_level_item = _{
    impl_block |
    custom_def |
    statement |
    error
}

impl_block = {
    keyword_impl ~ type_spec ~ "{" ~
    (function_def)* ~
    "}"
}

function_def = {
    keyword_fn ~ identifier ~ "(" ~
    (param ~ ("," ~ param)*)? ~
    ")" ~ ("->" ~ type_spec)? ~ block
}

param = {
    identifier ~ ":" ~ type_spec
}

//错误恢复规则
error = {
    ANY* ~ (";" | "{" | "}")
}

file = { 
    SOI ~ 
    (top_level_item ~ (WHITESPACE | COMMENT)*)* ~ 
    EOI 
}
